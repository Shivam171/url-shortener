package com.shvmpk.url_shortener.dto;

import jakarta.validation.constraints.*;
import lombok.*;
import org.hibernate.validator.constraints.URL;
import java.time.format.DateTimeParseException;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ShortUrlRequest {

    @NotBlank(message = "Long URL is required")
    @URL(message = "Invalid URL format")
    private String longUrl;

    @Pattern(regexp = "^[a-z0-9-]*$", message = "Alias must contain only lowercase letters, numbers, or dashes ('-')")
    private String alias;

    private Boolean isProtected;
    private Boolean isPasswordAutoGenerated;

    private String password;

    private String expiresAt;

    @Min(value = 1, message = "Max clicks must be at least 1")
    private Integer maxClicks;


    @AssertTrue(message = "Password is required when URL is protected and auto-generation is disabled")
    public boolean isPasswordValid() {
        if (Boolean.TRUE.equals(isProtected)) {
            if (Boolean.TRUE.equals(isPasswordAutoGenerated)) return true;
            return password != null && !password.trim().isEmpty();
        }
        return true;
    }

    @AssertTrue(message = "Password should not be provided when URL is not protected")
    public boolean isPasswordShouldNotExist() {
        return Boolean.TRUE.equals(isProtected) || (password == null || password.trim().isEmpty());
    }

    @AssertTrue(message = "Choose either maxClicks or expiresAt, not both")
    public boolean isExpirationChoiceValid() {
        return !(maxClicks != null && expiresAt != null && !expiresAt.trim().isEmpty());
    }

    @AssertTrue(message = "Expiration date must be in ISO format (yyyy-MM-dd'T'HH:mm) and a future date")
    public boolean isExpiresAtValid() {
        if (expiresAt == null || expiresAt.trim().isEmpty()) return true;

        try {
            LocalDateTime parsed = LocalDateTime.parse(expiresAt);
            return parsed.isAfter(LocalDateTime.now());
        } catch (DateTimeParseException e) {
            return false;
        }
    }

    @AssertTrue(message = "Alias must not be just whitespace")
    public boolean isAliasValid() {
        return alias == null || !alias.trim().isEmpty();
    }

    @AssertTrue(message = "Password must be at least 8 characters and include uppercase, lowercase, digit, and special character")
    public boolean isPasswordStrongEnough() {
        if (Boolean.TRUE.equals(isProtected) && Boolean.FALSE.equals(isPasswordAutoGenerated)) {
            if (password == null || password.length() < 8) return false;
            return password.matches("^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&#^()_+=\\-]).{8,}$");
        }
        return true;
    }
}
