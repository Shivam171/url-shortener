package com.shvmpk.url_shortener.service;

import com.shvmpk.url_shortener.dto.UrlVersionResponse;
import com.shvmpk.url_shortener.model.ShortCode;
import com.shvmpk.url_shortener.model.UrlVersion;
import com.shvmpk.url_shortener.repository.UrlRepository;
import com.shvmpk.url_shortener.repository.UrlVersionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.common.errors.ResourceNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Slf4j
@Service
@RequiredArgsConstructor
public class UrlVersionService {
    private final UrlVersionRepository urlVersionRepository;
    private final UrlRepository urlRepository;

    public List<UrlVersionResponse> getVersionsByShortCodeOrAlias(ShortCode shortCode) {
        List<UrlVersion> versions = urlVersionRepository.findByShortCodeOrderByVersionNumberDesc(shortCode);
        return versions.stream()
                .map(this::convertToResponse)
                .toList();
    }

    @Transactional
    public UrlVersionResponse rollbackToVersion(ShortCode shortCode, Integer versionNumber) {
        UrlVersion targetVersion = urlVersionRepository.findByShortCodeAndVersionNumber(shortCode, versionNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Version not found"));

        // Save current state as backup (optional)
        UrlVersion backupVersion = UrlVersion.builder()
                .shortCode(shortCode)
                .versionNumber(urlVersionRepository.findLatestVersionNumber(shortCode.getId()) + 1)
                .originalUrl(shortCode.getOriginalUrl())
                .alias(shortCode.getAlias())
                .isProtected(shortCode.getIsProtected())
                .isPasswordAutoGenerated(shortCode.getIsPasswordAutoGenerated())
                .password(shortCode.getPassword())
                .maxClicks(shortCode.getMaxClicks())
                .expiresAt(shortCode.getExpiresAt())
                .build();
        urlVersionRepository.save(backupVersion);

        // Apply rollback values to ShortCode
        shortCode.setOriginalUrl(targetVersion.getOriginalUrl());
        shortCode.setAlias(targetVersion.getAlias());
        shortCode.setIsProtected(targetVersion.getIsProtected());
        shortCode.setIsPasswordAutoGenerated(targetVersion.getIsPasswordAutoGenerated());
        shortCode.setPassword(targetVersion.getPassword());
        shortCode.setMaxClicks(targetVersion.getMaxClicks());
        shortCode.setExpiresAt(targetVersion.getExpiresAt());

        // Create rollback version entry
        UrlVersion rollbackVersion = UrlVersion.builder()
                .shortCode(shortCode)
                .versionNumber(urlVersionRepository.findLatestVersionNumber(shortCode.getId()) + 1)
                .originalUrl(targetVersion.getOriginalUrl())
                .alias(targetVersion.getAlias())
                .isProtected(targetVersion.getIsProtected())
                .isPasswordAutoGenerated(targetVersion.getIsPasswordAutoGenerated())
                .password(targetVersion.getPassword())
                .maxClicks(targetVersion.getMaxClicks())
                .expiresAt(targetVersion.getExpiresAt())
                .rollbackFromVersion(targetVersion.getVersionNumber())
                .isRollback(true)
                .build();

        UrlVersion savedRollback = urlVersionRepository.save(rollbackVersion);

        shortCode.setCurrentVersion(savedRollback);
        urlRepository.save(shortCode);

        return convertToResponse(savedRollback);
    }

    private UrlVersionResponse convertToResponse(UrlVersion version) {
        return UrlVersionResponse.builder()
                .versionNumber(version.getVersionNumber())
                .originalUrl(version.getOriginalUrl())
                .alias(version.getAlias())
                .isProtected(version.getIsProtected())
                .isPasswordAutoGenerated(version.getIsPasswordAutoGenerated())
                .password(version.getPassword())
                .maxClicks(version.getMaxClicks() != null ? version.getMaxClicks().longValue() : null)
                .expiresAt(version.getExpiresAt())
                .createdAt(version.getVersionCreatedAt())
                .rollbackFromVersion(version.getRollbackFromVersion())
                .isRollback(version.getIsRollback())
                .build();
    }

    public UrlVersionResponse getCurrentVersion(ShortCode shortCode) {
        UrlVersion current = shortCode.getCurrentVersion();
        if (current == null) {
            throw new ResourceNotFoundException("Current version not set");
        }
        return mapToResponse(current);
    }

    public Map<String, Map<String, Object>> compareVersions(ShortCode shortCode, Integer from, Integer to) {
        UrlVersion v1 = urlVersionRepository.findByShortCodeAndVersionNumber(shortCode, from)
                .orElseThrow(() -> new ResourceNotFoundException("From version not found"));
        UrlVersion v2 = urlVersionRepository.findByShortCodeAndVersionNumber(shortCode, to)
                .orElseThrow(() -> new ResourceNotFoundException("To version not found"));

        Map<String, Map<String, Object>> diff = new HashMap<>();
        compareField("originalUrl", v1.getOriginalUrl(), v2.getOriginalUrl(), diff);
        compareField("alias", v1.getAlias(), v2.getAlias(), diff);
        compareField("isProtected", v1.getIsProtected(), v2.getIsProtected(), diff);
        compareField("isPasswordAutoGenerated", v1.getIsPasswordAutoGenerated(), v2.getIsPasswordAutoGenerated(), diff);
        compareField("password", v1.getPassword(), v2.getPassword(), diff);
        compareField("maxClicks", v1.getMaxClicks(), v2.getMaxClicks(), diff);
        compareField("expiresAt", v1.getExpiresAt(), v2.getExpiresAt(), diff);
        return diff;
    }

    private UrlVersionResponse mapToResponse(UrlVersion version) {
        return UrlVersionResponse.builder()
                .versionNumber(version.getVersionNumber())
                .originalUrl(version.getOriginalUrl())
                .alias(version.getAlias())
                .isProtected(version.getIsProtected())
                .isPasswordAutoGenerated(version.getIsPasswordAutoGenerated())
                .password(version.getPassword())
                .maxClicks(version.getMaxClicks() != null ? version.getMaxClicks().longValue() : null)
                .expiresAt(version.getExpiresAt())
                .createdAt(version.getVersionCreatedAt())
                .rollbackFromVersion(version.getRollbackFromVersion())
                .isRollback(version.getIsRollback())
                .build();
    }

    private void compareField(String field, Object v1, Object v2, Map<String, Map<String, Object>> diff) {
        if (!Objects.equals(v1, v2)) {
            Map<String, Object> change = new HashMap<>();
            change.put("from", v1);
            change.put("to", v2);
            diff.put(field, change);
        }
    }

    @Transactional
    public String deleteSpecificVersionByShortCodeOrAlias(ShortCode shortCode, Integer versionNumber) {
        try{
            urlVersionRepository.deleteByShortCodeAndVersionNumber(shortCode, versionNumber);
            return "Successfully deleted " + versionNumber + " version for " + shortCode;
        } catch (Exception e){
            throw new RuntimeException("Failed to delete: "+ versionNumber + " version for " + shortCode);
        }
    }
}